/*
    SPDX-License-Identifier: AGPL-3.0-or-later
    SPDX-FileCopyrightText: 2025 Shomy
*/
pub mod carbonara;
pub mod kamakiri;
use crate::connection::port::ConnectionType;
use crate::da::protocol::DAProtocol;
use crate::error::Result;
const V6_PAYLOAD_MAGIC: &[u8] = b"PENUMBRAV6P";

pub enum BootStage {
    Brom,
    Preloader,
    Da1,
    Da2,
}

pub struct ExploitMeta {
    pub name: String,
    pub boot_mode: Vec<ConnectionType>, // In which mode the exploit works (BROM, Preloader, DA)
    pub boot_stage: BootStage,          /* In which stage the exploit works. (e.g. Kamakiri runs
                                         * in BROM, Carbonara in DA1) */
}

#[async_trait::async_trait]
pub trait Exploit {
    async fn run(&mut self, protocol: &mut dyn DAProtocol) -> Result<bool>;

    fn get_meta(&self) -> &ExploitMeta;
}

pub fn get_v6_payload(data: &[u8], is_arm64: bool) -> &[u8] {
    if data.len() < 16 + 4 * 4 {
        panic!("Data too short to contain a valid v6 header");
    }

    if &data[0..11] != V6_PAYLOAD_MAGIC {
        panic!("Invalid v6 payload magic");
    }

    // Remove the MAGIC
    let arm7_offset = u32::from_le_bytes(data[16..20].try_into().unwrap()) as usize + 8;
    let arm7_length = u32::from_le_bytes(data[20..24].try_into().unwrap()) as usize - 8;
    let arm64_offset = u32::from_le_bytes(data[24..28].try_into().unwrap()) as usize + 8;
    let arm64_length = u32::from_le_bytes(data[28..32].try_into().unwrap()) as usize - 8;

    if is_arm64 {
        &data[arm64_offset..arm64_offset + arm64_length]
    } else {
        &data[arm7_offset..arm7_offset + arm7_length]
    }
}
